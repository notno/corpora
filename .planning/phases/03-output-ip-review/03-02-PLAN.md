---
phase: 03-output-ip-review
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/corpora/ip/__init__.py
  - src/corpora/ip/blocklist.py
  - src/corpora/ip/detector.py
  - data/ip-blocklist.json
autonomous: true

must_haves:
  truths:
    - "User can load IP blocklist from JSON file organized by franchise"
    - "Terms matching blocklist are flagged with franchise name"
    - "Matching is case-insensitive"
  artifacts:
    - path: "src/corpora/ip/blocklist.py"
      provides: "IPBlocklist class for loading and matching"
      exports: ["IPBlocklist"]
    - path: "src/corpora/ip/detector.py"
      provides: "detect_ip function combining blocklist and classification"
      exports: ["detect_ip"]
    - path: "data/ip-blocklist.json"
      provides: "Default blocklist with common IP terms by franchise"
      contains: "dnd"
  key_links:
    - from: "src/corpora/ip/detector.py"
      to: "src/corpora/ip/blocklist.py"
      via: "uses IPBlocklist.check()"
      pattern: "blocklist\\.check"
---

<objective>
Create the IP flagging foundation: blocklist loading/matching and term detection for identifying potentially IP-encumbered vocabulary.

Purpose: This enables IP-01 (flag IP terms), IP-02 (configurable blocklist), and supports the legally critical IP review workflow.

Output: `src/corpora/ip/` module with blocklist.py, detector.py, and default blocklist data
</objective>

<execution_context>
@C:\Users\nrosq\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\nrosq\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-output-ip-review/03-CONTEXT.md
@.planning/phases/03-output-ip-review/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IP blocklist module with franchise-organized matching</name>
  <files>
    src/corpora/ip/__init__.py
    src/corpora/ip/blocklist.py
    data/ip-blocklist.json
  </files>
  <action>
Create `src/corpora/ip/` directory and module.

In `blocklist.py`, implement `IPBlocklist` class:

```python
class IPBlocklist:
    def __init__(self, blocklist_path: Optional[Path] = None):
        self.franchises: Dict[str, Set[str]] = {}
        self._patterns: Dict[str, List[re.Pattern]] = {}
        if blocklist_path and blocklist_path.exists():
            self.load(blocklist_path)

    def load(self, path: Path) -> None:
        # Load JSON: {"dnd": ["beholder", ...], "warhammer": [...]}
        # Store terms lowercase in self.franchises
        # Pre-compile regex patterns with word boundaries for multi-word matching

    def check(self, term: str, canonical: str) -> Optional[str]:
        # Return franchise name if matched, None otherwise
        # Check both term and canonical, case-insensitive
        # Use both direct set lookup and pattern matching
```

Create `data/ip-blocklist.json` with starter content:
```json
{
  "dnd": [
    "beholder", "mind flayer", "illithid", "yuan-ti", "githyanki", "githzerai",
    "forgotten realms", "greyhawk", "dragonlance", "eberron", "ravenloft",
    "vecna", "acererak", "demogorgon", "orcus", "lolth", "tiamat", "bahamut"
  ],
  "warhammer": [
    "space marine", "adeptus", "imperium", "chaos marine", "primarch",
    "warp", "tyranid", "ork", "necron", "eldar", "tau"
  ],
  "lotr": [
    "hobbit", "shire", "mordor", "gondor", "rohan", "moria", "rivendell",
    "balrog", "nazgul", "uruk-hai", "silmaril", "palantir"
  ]
}
```

In `__init__.py`, export IPBlocklist.
  </action>
  <verify>
python -c "
from corpora.ip import IPBlocklist
from pathlib import Path
bl = IPBlocklist(Path('data/ip-blocklist.json'))
print(f'Loaded {len(bl.franchises)} franchises')
result = bl.check('Beholder', 'beholder')
print(f'Beholder check: {result}')
result2 = bl.check('dragon', 'dragon')
print(f'Dragon check: {result2}')
"
  </verify>
  <done>
IPBlocklist loads from JSON, matches terms case-insensitively, returns franchise name for matches
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IP detector combining blocklist and classification flags</name>
  <files>
    src/corpora/ip/detector.py
    src/corpora/ip/__init__.py
  </files>
  <action>
Create `detector.py` with:

1. `detect_ip(term: ClassifiedTerm, blocklist: Optional[IPBlocklist] = None) -> Optional[str]`:
   - First check blocklist if provided
   - Then check if term already has ip_flag from classification
   - Return combined reason or None
   - Format: "blocklist:dnd" or "classification:ip-suspect" or "blocklist:dnd;classification:ip-suspect"

2. `flag_terms(terms: List[ClassifiedTerm], blocklist: Optional[IPBlocklist] = None) -> List[ClassifiedTerm]`:
   - Apply detect_ip to each term
   - Return new list with ip_flag set where detected
   - Use term.model_copy(update={"ip_flag": reason}) for immutable updates

This combines IP-01 (flag IP terms) with the dual detection approach from CONTEXT.md (blocklist + Claude detection during classification).

Add detect_ip and flag_terms to ip/__init__.py exports.
  </action>
  <verify>
python -c "
from corpora.ip import IPBlocklist, detect_ip, flag_terms
from corpora.models.vocabulary import ClassifiedTerm
from pathlib import Path

bl = IPBlocklist(Path('data/ip-blocklist.json'))
term = ClassifiedTerm(
    id='test-beholder', text='Beholder', source='test.pdf',
    intent='creature', pos='noun', category='creature',
    canonical='beholder', mood='dark', confidence=0.9
)
result = detect_ip(term, bl)
print(f'Beholder detected: {result}')

terms = flag_terms([term], bl)
print(f'Flagged term ip_flag: {terms[0].ip_flag}')
"
  </verify>
  <done>
detect_ip returns flag reason for IP terms, flag_terms batch-processes term list with ip_flag set
  </done>
</task>

</tasks>

<verification>
Run the IP module tests:
```bash
python -c "from corpora.ip import IPBlocklist, detect_ip, flag_terms; print('IP module imports OK')"
python -c "
from corpora.ip import IPBlocklist
from pathlib import Path
bl = IPBlocklist(Path('data/ip-blocklist.json'))
# Test multi-word matching
result = bl.check('Mind Flayer', 'mind flayer')
assert result == 'dnd', f'Expected dnd, got {result}'
# Test case insensitivity
result2 = bl.check('BEHOLDER', 'BEHOLDER')
assert result2 == 'dnd', f'Expected dnd, got {result2}'
# Test non-match
result3 = bl.check('dragon', 'dragon')
assert result3 is None, f'Expected None, got {result3}'
print('All IP blocklist tests passed')
"
```
</verification>

<success_criteria>
- IPBlocklist loads franchise-organized JSON
- Matching is case-insensitive for both term and canonical
- Multi-word terms (e.g., "mind flayer") match correctly
- detect_ip combines blocklist + classification detection
- flag_terms batch-processes terms with ip_flag set
- Default blocklist includes common D&D, Warhammer, LOTR terms
</success_criteria>

<output>
After completion, create `.planning/phases/03-output-ip-review/03-02-SUMMARY.md`
</output>
