---
phase: 01-document-parsing
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/corpora/parsers/ocr.py
  - src/corpora/parsers/pdf.py
  - src/corpora/parsers/__init__.py
  - src/corpora/cli/__init__.py
  - src/corpora/cli/main.py
  - src/corpora/cli/parse.py
autonomous: true

must_haves:
  truths:
    - "corpora parse <file> extracts text to stdout"
    - "corpora parse <file> -o output.json writes JSON file"
    - "OCR auto-detects and prompts before running (unless --yes)"
    - "--ocr forces OCR, --no-ocr skips it"
    - "Errors are logged to corpora-errors.log"
    - "--fail-fast stops on first error, default continues"
  artifacts:
    - path: "src/corpora/parsers/ocr.py"
      provides: "OCR detection and extraction"
      exports: ["needs_ocr_page", "extract_with_ocr", "is_ocr_available"]
    - path: "src/corpora/cli/main.py"
      provides: "Typer CLI app entry point"
      exports: ["app"]
    - path: "src/corpora/cli/parse.py"
      provides: "Parse subcommand implementation"
      contains: "def parse"
  key_links:
    - from: "src/corpora/cli/parse.py"
      to: "src/corpora/parsers"
      via: "import PDFParser, EPUBParser"
      pattern: "from corpora.parsers import"
    - from: "src/corpora/cli/parse.py"
      to: "src/corpora/parsers/ocr.py"
      via: "OCR integration"
      pattern: "from corpora.parsers.ocr import"
    - from: "src/corpora/cli/main.py"
      to: "src/corpora/cli/parse.py"
      via: "add_typer"
      pattern: "app.add_typer|app.command"
---

<objective>
Implement OCR fallback for scanned PDFs and the complete CLI with all flags from CONTEXT.md decisions.

Purpose: Complete the document parsing pipeline with OCR support (PARSE-03) and expose all functionality through the CLI that users will interact with.

Output: Fully functional `corpora parse` command with all specified flags and OCR integration.
</objective>

<execution_context>
@C:\Users\nrosq\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\nrosq\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-document-parsing/01-CONTEXT.md
@.planning/phases/01-document-parsing/01-RESEARCH.md
@.planning/phases/01-document-parsing/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OCR module</name>
  <files>
    src/corpora/parsers/ocr.py
    src/corpora/parsers/__init__.py
  </files>
  <action>
Create ocr.py with OCR detection and extraction functions:

is_ocr_available() -> bool:
- Try to import pytesseract
- Return False if ImportError
- Try pytesseract.get_tesseract_version() to verify Tesseract installed
- Return False if TesseractNotFoundError
- Return True if both available

needs_ocr_page(page: pymupdf.Page, text_threshold: int = 50, coverage_threshold: float = 0.8) -> bool:
- Per RESEARCH.md heuristics:
- Extract text with page.get_text().strip()
- If len(text) >= text_threshold, return False (has enough text)
- Check image coverage: get_images(), calculate bbox coverage
- If any image covers > coverage_threshold of page AND text is minimal, return True
- Return False otherwise

extract_with_ocr(page: pymupdf.Page, language: str = "eng") -> str:
- Use PyMuPDF's built-in OCR: page.get_textpage_ocr(language=language)
- Extract text from textpage
- Apply normalize_text() to result
- Return normalized text

needs_ocr_document(doc: pymupdf.Document, sample_pages: int = 3) -> bool:
- Check first N pages (or all if fewer)
- Return True if ANY sampled page needs OCR
- Used for pre-flight check before prompting user

Export: is_ocr_available, needs_ocr_page, extract_with_ocr, needs_ocr_document from parsers/__init__.py
  </action>
  <verify>
```bash
python -c "from corpora.parsers.ocr import is_ocr_available, needs_ocr_page; print(f'OCR available: {is_ocr_available()}')"
```
  </verify>
  <done>
OCR module detects whether Tesseract is available, identifies pages needing OCR via coverage heuristics, and extracts text using PyMuPDF's OCR integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI with all flags</name>
  <files>
    src/corpora/cli/main.py
    src/corpora/cli/parse.py
    src/corpora/cli/__init__.py
  </files>
  <action>
Create main.py with Typer app:
```python
import typer
from corpora.cli.parse import parse_command

app = typer.Typer(
    name="corpora",
    help="Extract vocabulary from documents",
    add_completion=False
)

app.command(name="parse")(parse_command)

if __name__ == "__main__":
    app()
```

Create parse.py with full parse command per CONTEXT.md decisions:

```python
@app.command()
def parse_command(
    input_path: Path = typer.Argument(..., help="File, folder, or glob pattern"),
    output: Optional[Path] = typer.Option(None, "--output", "-o", help="Output file or directory"),
    format: str = typer.Option("json", "--format", help="Output format (json)"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Verbose output"),
    ocr: Optional[bool] = typer.Option(None, "--ocr/--no-ocr", help="Force OCR on/off"),
    yes: bool = typer.Option(False, "--yes", "-y", help="Skip confirmation prompts"),
    fail_fast: bool = typer.Option(False, "--fail-fast", help="Stop on first error"),
    partial: bool = typer.Option(False, "--partial", help="Output partial results on error"),
    flat: bool = typer.Option(False, "--flat", help="Flatten document structure"),
):
```

Implementation logic:
1. Resolve input_path: single file, directory (all .pdf/.epub), or glob
2. For each file:
   - Select parser based on extension (PDFParser or EPUBParser)
   - If PDF and ocr is None (auto): check needs_ocr_document()
     - If needs OCR and not --yes: prompt "This document appears scanned. Use OCR? [y/N]"
     - If user declines, skip OCR (may have empty/poor results)
   - If ocr is True: force OCR on all pages
   - If ocr is False: never use OCR
   - Call parser.extract(path, flat=flat)
   - On error: log to corpora-errors.log via log_error()
     - If fail_fast: raise typer.Exit(65)
     - If partial: output what we have so far
     - Else: continue to next file
3. Output results:
   - If output is None: print JSON to stdout
   - If output is file: write JSON to that file
   - If output is directory: write {filename}.json for each input
4. Exit codes per RESEARCH.md:
   - 0: success
   - 2: usage error (invalid args)
   - 64: input error (file not found)
   - 65: data error (extraction failed)
   - 66: no input (no files matched)

Use Rich console for colored output when verbose.
Use typer.confirm() for OCR prompts.
  </action>
  <verify>
```bash
corpora parse --help
corpora --help
```

Expected: Help text showing all flags (--output, --verbose, --format, --ocr/--no-ocr, --yes, --fail-fast, --partial, --flat)

Test with a real file if available:
```bash
# If test.pdf exists:
corpora parse test.pdf
corpora parse test.pdf -o output.json
```
  </verify>
  <done>
CLI implements `corpora parse <input>` with all flags from CONTEXT.md. OCR auto-detection prompts user. Errors logged to corpora-errors.log. Exit codes follow conventions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `corpora parse --help` shows all specified flags
2. `corpora parse <pdf>` extracts and prints JSON to stdout
3. `corpora parse <epub>` extracts and prints JSON to stdout
4. `corpora parse <pdf> -o out.json` writes to file
5. OCR prompt appears for scanned PDFs (unless --yes)
6. `--fail-fast` stops on first error
7. Errors are appended to corpora-errors.log
</verification>

<success_criteria>
- CLI matches CONTEXT.md decisions exactly
- All flags work: -o, -v, --format, --ocr/--no-ocr, --yes, --fail-fast, --partial, --flat
- OCR auto-detection works and prompts appropriately
- Error handling follows CONTEXT.md (continue by default, log errors)
- Exit codes are sensible for scripting/CI
- Phase 1 success criteria from ROADMAP.md are achievable
</success_criteria>

<output>
After completion, create `.planning/phases/01-document-parsing/01-03-SUMMARY.md`
</output>
