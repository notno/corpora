---
phase: 02-vocabulary-extraction
plan: 03
type: execute
wave: 2
depends_on: [02-01, 02-02]
files_modified:
  - src/corpora/cli/extract.py
  - src/corpora/cli/main.py
  - tests/test_extract_cli.py
autonomous: true
requirements_covered: [EXTRACT-01, CLASS-01, CLASS-02, CLASS-03, CLASS-04, CLASS-05]

must_haves:
  truths:
    - "User can run 'corpora extract' command on parsed document JSON"
    - "Preview mode shows term count, sample, and estimated cost without API calls"
    - "Progress bar displays during classification by default"
    - "Verbose mode shows term-by-term classification output"
    - "Output validates against ClassifiedTerm schema"
  artifacts:
    - path: "src/corpora/cli/extract.py"
      provides: "CLI extract command implementation"
      exports: ["extract_command"]
    - path: "src/corpora/cli/main.py"
      provides: "Updated CLI with extract subcommand"
      contains: "app.command.*extract"
  key_links:
    - from: "src/corpora/cli/extract.py"
      to: "src/corpora/extraction/extractor.py"
      via: "TermExtractor import"
      pattern: "from corpora.extraction import"
    - from: "src/corpora/cli/extract.py"
      to: "src/corpora/classification/batch.py"
      via: "BatchClassifier import"
      pattern: "from corpora.classification import"
    - from: "src/corpora/cli/main.py"
      to: "src/corpora/cli/extract.py"
      via: "command registration"
      pattern: "app\\.command.*extract"
---

<objective>
Build the CLI command that integrates extraction and classification into a user-facing workflow.

Purpose: Connect the extraction module (Plan 01) and classification infrastructure (Plan 02) into a complete CLI experience with preview mode, progress tracking, and output handling.

Output:
- `corpora extract` CLI command
- Preview mode for cost estimation
- Progress bar for batch processing
- Verbose mode for debugging
- Tests for CLI behavior
</objective>

<execution_context>
@C:\Users\nrosq\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\nrosq\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-vocabulary-extraction/02-CONTEXT.md
@.planning/phases/02-vocabulary-extraction/02-RESEARCH.md
@.planning/phases/02-vocabulary-extraction/02-01-SUMMARY.md
@.planning/phases/02-vocabulary-extraction/02-02-SUMMARY.md
@src/corpora/cli/parse.py
@src/corpora/cli/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement extract CLI command</name>
  <files>
    src/corpora/cli/extract.py
  </files>
  <action>
Create the extract command following patterns from parse.py:

```python
"""Extract subcommand for vocabulary extraction and classification.

Implements the `corpora extract` command with flags from CONTEXT.md:
- Input: Parsed document JSON from Phase 1
- Output: Classified vocabulary JSON (stdout or file via -o)
- Preview: --preview shows term count, sample, and estimated cost
- Progress: Progress bar by default, verbose (-v) for term-by-term
"""

import json
import sys
from pathlib import Path
from typing import List, Optional

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from rich.table import Table

from corpora.models import DocumentOutput, ClassifiedTerm
from corpora.extraction import TermExtractor
from corpora.classification import BatchClassifier, ClassificationClient

# Exit codes (same convention as parse.py)
EXIT_SUCCESS = 0
EXIT_USAGE_ERROR = 2
EXIT_INPUT_ERROR = 64
EXIT_DATA_ERROR = 65
EXIT_NO_INPUT = 66

console = Console(stderr=True)
output_console = Console()


def load_document(path: Path) -> DocumentOutput:
    """Load parsed document JSON from Phase 1.

    Args:
        path: Path to JSON file

    Returns:
        DocumentOutput parsed from file

    Raises:
        typer.Exit: If file is invalid
    """
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        return DocumentOutput.model_validate(data)
    except FileNotFoundError:
        console.print(f"[red]Error:[/red] File not found: {path}")
        raise typer.Exit(EXIT_NO_INPUT)
    except json.JSONDecodeError as e:
        console.print(f"[red]Error:[/red] Invalid JSON: {e}")
        raise typer.Exit(EXIT_DATA_ERROR)
    except Exception as e:
        console.print(f"[red]Error:[/red] Failed to load document: {e}")
        raise typer.Exit(EXIT_DATA_ERROR)


def extract_text_from_document(doc: DocumentOutput) -> str:
    """Extract all text from a parsed document.

    Args:
        doc: Parsed document from Phase 1

    Returns:
        Combined text from all content blocks
    """
    return "\n\n".join(block.text for block in doc.content)


def extract_command(
    input_file: Path = typer.Argument(
        ...,
        help="Parsed document JSON from Phase 1",
        exists=True,
    ),
    output: Optional[Path] = typer.Option(
        None,
        "--output",
        "-o",
        help="Output file (default: stdout)",
    ),
    preview: bool = typer.Option(
        False,
        "--preview",
        help="Preview extraction without API calls (shows count, sample, cost estimate)",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Verbose output (term-by-term instead of progress bar)",
    ),
    batch_size: int = typer.Option(
        50,
        "--batch-size",
        help="Terms per batch request",
    ),
    sync_mode: bool = typer.Option(
        False,
        "--sync",
        help="Use synchronous API instead of Batch API (faster but more expensive)",
    ),
) -> None:
    """Extract and classify vocabulary from parsed documents.

    Takes a JSON file from the 'corpora parse' command and extracts
    fantasy-relevant vocabulary, then classifies each term using Claude API.

    Examples:
        corpora extract document.json
        corpora extract document.json --preview
        corpora extract document.json -o vocabulary.json
        corpora extract document.json -v --sync
    """
    # Load the parsed document
    doc = load_document(input_file)
    source = Path(doc.source).stem  # Use source filename as identifier

    if verbose:
        console.print(f"Loaded document: {doc.source}")
        console.print(f"Format: {doc.format}, Blocks: {len(doc.content)}")

    # Extract text and candidates
    text = extract_text_from_document(doc)
    extractor = TermExtractor()
    candidates = extractor.extract(text)

    if verbose:
        console.print(f"Extracted {len(candidates)} candidate terms")

    if not candidates:
        console.print("[yellow]No vocabulary candidates found[/yellow]")
        raise typer.Exit(EXIT_SUCCESS)

    # Preview mode: show stats and exit
    if preview:
        _show_preview(candidates, source, batch_size, sync_mode)
        raise typer.Exit(EXIT_SUCCESS)

    # Classification
    if sync_mode:
        # Synchronous classification (faster turnaround, higher cost)
        results = _classify_sync(candidates, source, verbose)
    else:
        # Batch API classification (slower, 50% cheaper)
        results = _classify_batch(candidates, source, batch_size, verbose)

    # Output results
    _write_results(results, output, verbose)


def _show_preview(candidates, source: str, batch_size: int, sync_mode: bool) -> None:
    """Show preview statistics without making API calls."""
    console.print("\n[bold]Extraction Preview[/bold]")
    console.print(f"Source: {source}")
    console.print(f"Total candidates: {len(candidates)}")

    # Show sample terms
    console.print("\n[bold]Sample terms:[/bold]")
    table = Table(show_header=True, header_style="bold")
    table.add_column("Term")
    table.add_column("POS")
    table.add_column("Lemma")

    for term in candidates[:10]:
        table.add_row(term.text, term.pos, term.lemma)

    console.print(table)

    # Show POS distribution
    pos_counts = {}
    for term in candidates:
        pos_counts[term.pos] = pos_counts.get(term.pos, 0) + 1

    console.print("\n[bold]POS Distribution:[/bold]")
    for pos, count in sorted(pos_counts.items()):
        console.print(f"  {pos}: {count}")

    # Cost estimate
    client = ClassificationClient.__new__(ClassificationClient)
    estimate = client.estimate_cost(len(candidates), use_batch=not sync_mode)

    console.print(f"\n[bold]Cost Estimate:[/bold]")
    console.print(f"  Mode: {'Sync API' if sync_mode else 'Batch API'}")
    console.print(f"  Est. input tokens: {estimate['est_input_tokens']:,}")
    console.print(f"  Est. output tokens: {estimate['est_output_tokens']:,}")
    console.print(f"  Est. cost: [green]${estimate['est_cost_usd']:.4f}[/green]")

    if not sync_mode:
        console.print(f"\n[dim]Batch processing may take 5-60 minutes depending on load.[/dim]")


def _classify_sync(
    candidates,
    source: str,
    verbose: bool,
) -> List[ClassifiedTerm]:
    """Classify terms using synchronous API (with progress)."""
    client = ClassificationClient()
    results = []
    errors = []

    if verbose:
        # Term-by-term output
        for term in candidates:
            console.print(f"Classifying: {term.text}...", end=" ")
            try:
                result = client.classify_term(term.text, source)
                results.append(result)
                console.print(f"[green]OK[/green] ({result.intent}, {result.category})")
            except Exception as e:
                console.print(f"[red]Error:[/red] {e}")
                errors.append((term.text, str(e)))
    else:
        # Progress bar
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console,
        ) as progress:
            task = progress.add_task("Classifying terms...", total=len(candidates))

            for term in candidates:
                try:
                    result = client.classify_term(term.text, source)
                    results.append(result)
                except Exception as e:
                    errors.append((term.text, str(e)))
                progress.update(task, advance=1)

    if errors:
        console.print(f"[yellow]Warning:[/yellow] {len(errors)} terms failed classification")
        if verbose:
            for term, error in errors[:5]:
                console.print(f"  - {term}: {error}")

    return results


def _classify_batch(
    candidates,
    source: str,
    batch_size: int,
    verbose: bool,
) -> List[ClassifiedTerm]:
    """Classify terms using Batch API (cheaper, slower)."""
    classifier = BatchClassifier()
    results = []
    errors = []

    # Prepare term list
    terms = [(c.text, source) for c in candidates]

    if verbose:
        console.print(f"Creating batch with {len(terms)} terms...")

    # Create batch
    try:
        batch_id = classifier.create_batch(terms)
    except Exception as e:
        console.print(f"[red]Error creating batch:[/red] {e}")
        raise typer.Exit(EXIT_DATA_ERROR)

    if verbose:
        console.print(f"Batch created: {batch_id}")
        console.print("Waiting for completion (this may take several minutes)...")

    # Poll for completion
    def on_progress(completed: int, total: int):
        if verbose:
            console.print(f"  Progress: {completed}/{total}")

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
        transient=not verbose,
    ) as progress:
        task = progress.add_task("Processing batch...", total=None)

        try:
            classifier.poll_batch(
                batch_id,
                poll_interval=30,
                on_progress=on_progress if verbose else None,
            )
        except KeyboardInterrupt:
            console.print("\n[yellow]Interrupted. Batch continues on server.[/yellow]")
            console.print(f"Resume with: corpora extract --batch-id {batch_id}")
            raise typer.Exit(EXIT_SUCCESS)

        progress.update(task, description="Retrieving results...")

    # Stream results
    for idx, result in classifier.stream_results(batch_id, source):
        if isinstance(result, ClassifiedTerm):
            results.append(result)
            if verbose:
                console.print(f"  {result.text}: {result.intent}, {result.category}")
        else:
            errors.append((candidates[idx].text if idx < len(candidates) else f"idx-{idx}", result.get("error", "Unknown")))

    if errors:
        console.print(f"[yellow]Warning:[/yellow] {len(errors)} terms failed classification")
        if verbose:
            for term, error in errors[:5]:
                console.print(f"  - {term}: {error}")

    return results


def _write_results(
    results: List[ClassifiedTerm],
    output: Optional[Path],
    verbose: bool,
) -> None:
    """Write classification results to output."""
    if not results:
        console.print("[yellow]No results to output[/yellow]")
        return

    # Serialize results
    output_data = [r.model_dump() for r in results]

    if output is None:
        # Write to stdout
        output_console.print(json.dumps(output_data, indent=2))
    else:
        # Write to file
        output.parent.mkdir(parents=True, exist_ok=True)
        with open(output, "w", encoding="utf-8") as f:
            json.dump(output_data, f, indent=2)

        if verbose:
            console.print(f"[green]Written {len(results)} terms to {output}[/green]")
        else:
            console.print(f"Wrote {len(results)} classified terms to {output}")
```
  </action>
  <verify>
    python -c "from corpora.cli.extract import extract_command; print('Extract command importable')"
  </verify>
  <done>
    Extract command exists with preview mode, progress bar, verbose mode, sync/batch options
  </done>
</task>

<task type="auto">
  <name>Task 2: Register extract command in CLI</name>
  <files>
    src/corpora/cli/main.py
  </files>
  <action>
Update the main CLI to include the extract command:

```python
"""Main CLI application for corpora."""

import typer

from corpora.cli.parse import parse_command
from corpora.cli.extract import extract_command

app = typer.Typer(
    name="corpora",
    help="Corpora: Extract vocabulary from documents into structured JSON",
    add_completion=False,
)

# Register subcommands
app.command(name="parse")(parse_command)
app.command(name="extract")(extract_command)


@app.callback(invoke_without_command=True)
def main(
    ctx: typer.Context,
    version: bool = typer.Option(
        False, "--version", "-V", help="Show version and exit"
    ),
) -> None:
    """Corpora: Extract vocabulary from documents into structured JSON."""
    if version:
        from corpora import __version__
        typer.echo(f"corpora {__version__}")
        raise typer.Exit()

    if ctx.invoked_subcommand is None:
        typer.echo(ctx.get_help())
```
  </action>
  <verify>
    python -m corpora --help | grep -q "extract" && echo "Extract command registered"
  </verify>
  <done>
    'corpora extract' appears in CLI help output
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI tests</name>
  <files>
    tests/test_extract_cli.py
  </files>
  <action>
Create tests for the extract CLI command:

```python
"""Tests for the extract CLI command."""

import json
import pytest
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from typer.testing import CliRunner

from corpora.cli.main import app
from corpora.models import DocumentOutput, ContentBlock, ClassifiedTerm, AxisScores


runner = CliRunner()


@pytest.fixture
def sample_document(tmp_path):
    """Create a sample parsed document JSON."""
    doc = DocumentOutput(
        source="test.pdf",
        format="pdf",
        ocr_used=False,
        metadata={"title": "Test"},
        content=[
            ContentBlock(
                type="text",
                text="The wizard cast a powerful fireball spell at the ancient dragon.",
                page=1,
            )
        ],
    )
    path = tmp_path / "test.json"
    doc.to_json_file(str(path))
    return path


class TestExtractCommand:
    def test_extract_help(self):
        result = runner.invoke(app, ["extract", "--help"])
        assert result.exit_code == 0
        assert "Extract and classify vocabulary" in result.stdout

    def test_extract_missing_file(self):
        result = runner.invoke(app, ["extract", "nonexistent.json"])
        assert result.exit_code != 0

    @patch("corpora.cli.extract.TermExtractor")
    def test_extract_preview_mode(self, mock_extractor_class, sample_document):
        """Preview mode should not make API calls."""
        # Mock extractor
        mock_extractor = Mock()
        mock_extractor.extract.return_value = [
            Mock(text="wizard", lemma="wizard", pos="noun", source_span=(4, 10)),
            Mock(text="fireball", lemma="fireball", pos="noun", source_span=(35, 43)),
            Mock(text="dragon", lemma="dragon", pos="noun", source_span=(64, 70)),
        ]
        mock_extractor_class.return_value = mock_extractor

        result = runner.invoke(app, ["extract", str(sample_document), "--preview"])

        assert result.exit_code == 0
        assert "Extraction Preview" in result.stdout
        assert "Total candidates: 3" in result.stdout
        assert "Cost Estimate" in result.stdout

    @patch("corpora.cli.extract.TermExtractor")
    @patch("corpora.cli.extract.ClassificationClient")
    def test_extract_sync_mode(self, mock_client_class, mock_extractor_class, sample_document, tmp_path):
        """Sync mode should use ClassificationClient."""
        # Mock extractor
        mock_extractor = Mock()
        mock_extractor.extract.return_value = [
            Mock(text="fireball", lemma="fireball", pos="noun", source_span=(0, 8)),
        ]
        mock_extractor_class.return_value = mock_extractor

        # Mock classifier
        mock_client = Mock()
        mock_client.classify_term.return_value = ClassifiedTerm(
            id="test-fireball",
            text="Fireball",
            source="test",
            genre="fantasy",
            intent="offensive",
            pos="noun",
            axes=AxisScores(fire=0.9, force=0.7),
            tags=["evocation"],
            category="spell",
            canonical="fireball",
            mood="arcane",
            energy="fire",
            confidence=0.95,
        )
        mock_client_class.return_value = mock_client

        output_file = tmp_path / "output.json"
        result = runner.invoke(app, [
            "extract", str(sample_document),
            "--sync",
            "-o", str(output_file),
        ])

        assert result.exit_code == 0
        assert output_file.exists()

        with open(output_file) as f:
            data = json.load(f)
        assert len(data) == 1
        assert data[0]["text"] == "Fireball"

    @patch("corpora.cli.extract.TermExtractor")
    def test_extract_no_candidates(self, mock_extractor_class, sample_document):
        """Should handle documents with no extractable terms."""
        mock_extractor = Mock()
        mock_extractor.extract.return_value = []
        mock_extractor_class.return_value = mock_extractor

        result = runner.invoke(app, ["extract", str(sample_document)])

        assert result.exit_code == 0
        assert "No vocabulary candidates found" in result.stdout


class TestExtractIntegration:
    """Integration tests that use real extraction (but mock API)."""

    @patch("corpora.cli.extract.ClassificationClient")
    def test_real_extraction_mock_classification(self, mock_client_class, sample_document, tmp_path):
        """Use real spaCy extraction but mock the API."""
        # Mock classifier to return valid responses
        mock_client = Mock()

        def classify_side_effect(term, source):
            return ClassifiedTerm(
                id=f"test-{term.lower().replace(' ', '-')}",
                text=term.title(),
                source=source,
                genre="fantasy",
                intent="utility",
                pos="noun",
                axes=AxisScores(),
                tags=[],
                category="general",
                canonical=term.lower(),
                mood="neutral",
                energy="none",
                confidence=0.8,
            )

        mock_client.classify_term.side_effect = classify_side_effect
        mock_client_class.return_value = mock_client

        output_file = tmp_path / "output.json"
        result = runner.invoke(app, [
            "extract", str(sample_document),
            "--sync",
            "-o", str(output_file),
        ])

        # Should succeed with real extraction
        assert result.exit_code == 0
        assert output_file.exists()

        with open(output_file) as f:
            data = json.load(f)

        # Should have extracted some terms
        assert len(data) > 0
```
  </action>
  <verify>
    pytest tests/test_extract_cli.py -v
  </verify>
  <done>
    CLI tests pass, covering help, preview mode, sync mode, and error handling
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **CLI help shows extract:**
   ```bash
   python -m corpora --help
   # Should show both 'parse' and 'extract' commands
   ```

2. **Extract help works:**
   ```bash
   python -m corpora extract --help
   # Should show all options: --preview, -v, -o, --sync, --batch-size
   ```

3. **Preview mode (no API call):**
   ```bash
   # Create a test document first
   echo '{"source":"test.pdf","format":"pdf","extracted_at":"2024-01-01T00:00:00","ocr_used":false,"metadata":{},"content":[{"type":"text","text":"The wizard cast a fireball at the dragon.","page":1}]}' > /tmp/test.json

   python -m corpora extract /tmp/test.json --preview
   # Should show: Total candidates, Sample terms, Cost Estimate
   ```

4. **All tests pass:**
   ```bash
   pytest tests/test_extract_cli.py -v
   ```
</verification>

<success_criteria>
- 'corpora extract' command is registered and shows in --help
- Preview mode shows term count, sample, and cost estimate without API calls
- Progress bar displays during classification (default mode)
- Verbose mode shows term-by-term output
- Sync mode uses ClassificationClient with retry logic
- Batch mode uses BatchClassifier for 50% cost savings
- Output validates against ClassifiedTerm schema (JSON array)
- All CLI tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-vocabulary-extraction/02-03-SUMMARY.md`
</output>
